#!/usr/bin/env python3
# encoding: utf-8

"""Interact with other programs using command-line semantics."""

from contextlib import contextmanager
import os
import subprocess
import sys

# networkx must be installed before use
#   $ sudo apt-get install python-networkx
import networkx

import gitgraph.common

# important to read - the graphml won't render nicely by default:
# http://thirld.com/blog/2012/01/31/making-yed-import-labels-from-graphml-files/


class Worker():
    """Simulate a person working with a supplied workflow.

    The worker has a name and is assigned a project to work on, they will
    perform the work in supplied list of items.
    """

    def __init__(self, name, project, items):
        self.name = name
        self.project = project
        self.items = items

    def work(self, workflow):
        yield  # XXX: we must yield immediately due to a quirk of simulate()
        workflow.start_project(self.name, self.project)
        for item in self.items:
            workflow.do_item(self.name, self.project, item)
            yield
        workflow.finish_project(self.name, self.project)


def main():
    # setup our workers
    alice = Worker("Alice", "wonderland", ["sleep", "awake"])
    bob = Worker("Bob", "zoo", ["build zoo", "fix zoo", "rebuild zoo"])
    charley = Worker("Charley", "sez", ["one", "two", "three", "four", "five"])
    dorian = Worker("Dorian", "painting", ["nose", "eyes", "hair", "grin"])

    # the workers will participate in all of these workflows
    workers = [alice, bob, charley, dorian]
    workflows = [
        RebaseMasterWorkflow(),
        RebaseTopicFfOnlyWorkflow(),
        RebaseTopicNoFfWorkflow(),
        SquashTopicWorkflow(),
        MergeTopicWorkflow(),
        MergeTopicCatchupWorkflow(),
        SvnWorkflow(),
        SvnPullWorkflow()
    ]

    # we'll be building a graph of all the commits on master at the end
    # of each simulation
    g = networkx.DiGraph()

    # run all the simulations
    for workflow in workflows:
        doWorkflow(g, workflow, workers)

    # write the graph in the 'graphml' format, this is useful because the
    # 'yEd' editor will allow us to load the graph and manipulate it into a
    # form that we are happy with
    graphml = '\n'.join(networkx.generate_graphml(g))
    with open("all.graphml", "w") as f:
        f.write(graphml)


def doWorkflow(g, workflow, workers):
    tempdir_name = "_workflow_tempdir"
    subprocess.check_call(["rm", "-rf", tempdir_name])
    subprocess.check_call(["mkdir", tempdir_name])

    central_repo_name = "origin"

    repo = gitgraph.common.GitRepo(central_repo_name)

    with chDirContext(tempdir_name):
        createCentralizedRepoAndWorkers(
            central_repo_name,
            [w.name for w in workers])
        execute(workers, workflow)

        text_graph = repo("log", "--graph", "--oneline")
        connections = repo("log", "--format=%f %h %p")

    subprocess.check_call(["rm", "-rf", tempdir_name])

    print(text_graph)
    namespace = ''.join(workflow.title().split())
    addToGraph(g, namespace, connections)


def createCentralizedRepoAndWorkers(central_repo_name, worker_names):
    subprocess.check_call(["mkdir", central_repo_name])
    with chDirContext(central_repo_name):
        subprocess.check_call(["git", "init", "--bare"])
    for w in worker_names:
        subprocess.check_call(["git", "clone", central_repo_name, w])
    worker = worker_names[0]
    with chDirContext(worker):
        subprocess.check_call(["touch", "README"])
        subprocess.check_call(["git", "add", "README"])
        subprocess.check_call(["git", "commit", "README", "-m", "initial commit"])
        subprocess.check_call(["git", "push", "origin", "master"])
    for w in worker_names:
        with chDirContext(w):
            subprocess.check_call(["git", "pull"])


def addToGraph(g, namespace, connections_text):
    """Parse the connections_text and create a graph from it.

    Uses the Solarized color scheme.

    """
    # XXX: this should be split up, we may want to create a standlone tool
    # which can map out arbitrary git repositories

    lines = connections_text.splitlines()
    for l in lines:
        commit_info = l.split()
        subject = commit_info[0]
        name = namespace + "_" + commit_info[1]
        parents = commit_info[2:]

        label = ""
        color = "#fdf6e3"

        project_to_color = [
            ["sez", "#b58900"],
            ["painting", "#cb4b16"],
            ["zoo", "#dc322f"],
            ["wonderland", "#d33682"],
            ["merge", "#eee8d5"],
            ["initial", "#839496"],
        ]
        for pc in project_to_color:
            if subject.startswith(pc[0]):
                color = pc[1]

        g.add_node(name, label=label, color=color)
        for p in parents:
            p_name = namespace + "_" + p
            g.add_edge(name, p_name)


def execute(workers, workflow):

    jobsDirs = [(w.work(workflow), w.name) for w in workers]
    next_jobsDirs = []

    # complete all the jobs from the workers
    while jobsDirs:
        for (j, d) in jobsDirs:
            with chDirContext(d):
                try:
                    next(j)
                    next_jobsDirs.append((j, d))
                except StopIteration:
                    pass
        jobsDirs = next_jobsDirs
        next_jobsDirs = []


def unindent(s):
    s = s.strip()
    lines = s.splitlines()
    lines = [l.strip() for l in lines]
    s = '\n'.join(lines)
    return s


def commitAppendToFile(filename, text, message):
    with open(filename, "a") as f:
        f.write(text + "\n")
    subprocess.check_call(["git", "add", filename])
    subprocess.check_call(["git", "commit", filename, "-m", message])


def commitAppendToProjectFile(name, project, item):
    commitAppendToFile(
        project,
        item,
        project + ": " + item + " (" + name + ")")


class RebaseMasterWorkflow():

    def title(self):
        return "Rebase on Master"

    def description(self):
        return "Commit on master, rebase often, push when done"

    def workflow(self):
        return """
            .. commit some work ..
            $ git pull --rebase
            .. commit some work ..
            $ git pull --rebase
            $ git push origin master
            """

    def start_project(self, name, project):
        pass

    def update(self, name, project):
        pass

    def do_item(self, name, project, item):
        commitAppendToProjectFile(name, project, item)

    def finish_project(self, name, project):
        subprocess.check_call(["git", "pull", "--rebase"])
        subprocess.check_call(["git", "push", "origin", "master"])


class RebaseTopicFfOnlyWorkflow():

    def title(self):
        return "Topic branches, rebase, ff-only merge"

    def description(self):
        return "Work on a topic branch, rebase often; ff-only merge to master"

    def workflow(self):
        return """
            $ git checkout -b mywork
            .. commit some work ..
            $ git fetch
            $ git rebase origin/master
            .. commit some work ..
            $ git fetch
            $ git rebase origin/master

            $ git checkout master
            $ git merge origin/master --ff-only
            $ git merge mywork --ff-only
            $ git branch -d mywork
            $ git push origin master
            """

    def start_project(self, name, project):
        subprocess.check_call(["git", "checkout", "-b", project])

    def update(self, name, project):
        subprocess.check_call(["git", "fetch"])
        subprocess.check_call(["git", "rebase", "origin/master"])

    def do_item(self, name, project, item):
        commitAppendToProjectFile(name, project, item)

    def finish_project(self, name, project):
        subprocess.check_call(["git", "fetch"])
        subprocess.check_call(["git", "rebase", "origin/master"])
        subprocess.check_call(["git", "checkout", "-B", "master", "origin/master"])
        subprocess.check_call(["git", "merge", project, "--ff-only"])
        subprocess.check_call(["git", "branch", "-d", project])
        subprocess.check_call(["git", "push", "origin", "master"])


class SquashTopicWorkflow():

    def title(self):
        return "Topic branches, squash"

    def description(self):
        return "Work on a topic branch, squash work back to master when done"

    def workflow(self):
        return """
            $ git checkout -b mywork
            .. commit some work ..
            .. commit some work ..

            $ git fetch
            $ git checkout master
            $ git merge origin/master --ff-only
            $ git merge mywork --squash
            $ git commit
            $ git branch -D mywork
            $ git push origin master
            """

    def start_project(self, name, project):
        subprocess.check_call(["git", "checkout", "-b", project])

    def update(self, name, project):
        pass

    def do_item(self, name, project, item):
        commitAppendToProjectFile(name, project, item)

    def finish_project(self, name, project):
        subprocess.check_call(["git", "fetch"])
        subprocess.check_call(["git", "checkout", "-B", "master", "origin/master"])
        subprocess.check_call(["git", "merge", project, "--squash"])
        subprocess.check_call(["git", "commit", "-m", project + " (" + name + ")"])
        subprocess.check_call(["git", "branch", "-D", project])
        subprocess.check_call(["git", "push", "origin", "master"])


class RebaseTopicNoFfWorkflow():

    def title(self):
        return "Topic branches, rebase, no-ff merge"

    def description(self):
        return "Work on a topic branch, rebase often; no-ff merge to master"

    def workflow(self):
        return """
            $ git checkout -b mywork
            .. commit some work ..
            $ git fetch
            $ git rebase origin/master
            .. commit some work ..
            $ git fetch
            $ git rebase origin/master

            $ git checkout master
            $ git merge origin/master --ff-only
            $ git merge mywork --no-ff
            $ git branch -d mywork
            $ git push origin master
            """

    def start_project(self, name, project):
        subprocess.check_call(["git", "checkout", "-b", project])

    def update(self, name, project):
        subprocess.check_call(["git", "fetch"])
        subprocess.check_call(["git", "rebase", "origin/master"])

    def do_item(self, name, project, item):
        commitAppendToProjectFile(name, project, item)

    def finish_project(self, name, project):
        subprocess.check_call(["git", "fetch"])
        subprocess.check_call(["git", "rebase", "origin/master"])
        subprocess.check_call(["git", "checkout", "-B", "master", "origin/master"])
        subprocess.check_call(["git", "merge", project, "--no-ff"])
        subprocess.check_call(["git", "branch", "-d", project])
        subprocess.check_call(["git", "push", "origin", "master"])


class MergeTopicWorkflow():

    def title(self):
        return "Topic branches, merge"

    def description(self):
        return "Work on a topic branch, merge back to master"

    def workflow(self):
        return """
            $ git checkout -b mywork
            .. commit some work ..
            .. commit some work ..

            $ git fetch
            $ git checkout master
            $ git merge origin/master
            $ git merge mywork
            $ git branch -d mywork
            $ git push origin master
            """

    def start_project(self, name, project):
        subprocess.check_call(["git", "checkout", "-b", project])

    def update(self, name, project):
        subprocess.check_call(["git", "fetch"])
        subprocess.check_call(["git", "rebase", "origin/master"])

    def do_item(self, name, project, item):
        commitAppendToProjectFile(name, project, item)

    def finish_project(self, name, project):
        subprocess.check_call(["git", "fetch"])
        subprocess.check_call(["git", "checkout", "-B", "master", "origin/master"])
        subprocess.check_call(["git", "merge", project])
        subprocess.check_call(["git", "branch", "-d", project])
        subprocess.check_call(["git", "push", "origin", "master"])


class MergeTopicCatchupWorkflow():

    def title(self):
        return "Topic branches, merge catchup"

    def description(self):
        return "Work on a topic branch, merge catch-up, merge back to master"

    def workflow(self):
        return """
            $ git checkout -b mywork
            .. commit some work ..
            $ git fetch
            $ git merge origin/master
            .. commit some work ..
            $ git fetch
            $ git merge origin/master

            $ git checkout master
            $ git merge origin/master
            $ git merge mywork
            $ git branch -d mywork
            $ git push origin master
            """

    def start_project(self, name, project):
        subprocess.check_call(["git", "checkout", "-b", project])

    def update(self, name, project):
        subprocess.check_call(["git", "fetch"])
        subprocess.check_call(["git", "rebase", "origin/master"])

    def do_item(self, name, project, item):
        commitAppendToProjectFile(name, project, item)
        subprocess.check_call(["git", "fetch"])
        subprocess.check_call(["git", "merge", "origin/master"])

    def finish_project(self, name, project):
        subprocess.check_call(["git", "fetch"])
        subprocess.check_call(["git", "checkout", "-B", "master", "origin/master"])
        subprocess.check_call(["git", "merge", project])
        subprocess.check_call(["git", "branch", "-d", project])
        subprocess.check_call(["git", "push", "origin", "master"])


class SvnWorkflow():

    def title(self):
        return "The SVN workflow"

    def description(self):
        return "Work on master, rebase and push every individual commit"

    def workflow(self):
        return """
            .. commit some work ..
            $ git pull --rebase
            $ git push origin master
            .. commit some work ..
            $ git pull --rebase
            $ git push origin master
            """

    def start_project(self, name, project):
        pass

    def update(self, name, project):
        pass

    def do_item(self, name, project, item):
        commitAppendToProjectFile(name, project, item)
        subprocess.check_call(["git", "pull", "--rebase"])
        subprocess.check_call(["git", "push", "origin", "master"])

    def finish_project(self, name, project):
        subprocess.check_call(["git", "pull", "--rebase"])
        subprocess.check_call(["git", "push", "origin", "master"])


class SvnPullWorkflow():

    def title(self):
        return "The SVN workflow, merge-o-geddon"

    def description(self):
        return "Work on master, pull and push every individual commit"

    def workflow(self):
        return """
            .. commit some work ..
            $ git pull
            $ git push origin master
            .. commit some work ..
            $ git pull
            $ git push origin master
            """

    def start_project(self, name, project):
        pass

    def update(self, name, project):
        pass

    def do_item(self, name, project, item):
        commitAppendToProjectFile(name, project, item)
        subprocess.check_call(["git", "pull"])
        subprocess.check_call(["git", "push", "origin", "master"])

    def finish_project(self, name, project):
        subprocess.check_call(["git", "pull"])
        subprocess.check_call(["git", "push", "origin", "master"])


# TODO: write a docstring with doctests when we have a tempdir helper
@contextmanager
def chDirContext(newDir):
    savedPath = os.getcwd()
    os.chdir(newDir)
    try:
        yield
    finally:
        os.chdir(savedPath)


if __name__ == "__main__":
    sys.exit(main())
